{-# LANGUAGE TemplateHaskell, MultiParamTypeClasses, FlexibleInstances #-}
module Bio.PDB.InstantiateIterable(Iterable(..), gen_iterable, trans_iterable) where

import Language.Haskell.TH.Syntax
import Control.Monad.Identity(runIdentity,foldM)
import Data.List(foldl')

class Iterable a b where
  imapM  :: (Monad m) => (b -> m b) -> a -> m a
  imap   ::              (b ->   b) -> a ->   a
  imap f e = runIdentity $ imapM (\b -> return $ f b) e
  ifoldM :: (Monad m) => (c -> b -> m c) -> c -> a -> m c
  ifold  ::              (c -> b ->   c) -> c -> a ->   c
{-
gen_render :: Name -> Q [Dec]
gen_render typName =
  do (TyConI d) <- reify typName -- Get all the information on the type
     (type_name,_,_,constructors) <- typeInfo (return d) -- extract name and constructors                  
     i_dec <- gen_instance (mkName "TH_Render") (conT type_name) constructors
                      -- generation function for method "render"
                      [(mkName "render", gen_render)]
     return [i_dec]  -- return the instance declaration
             -- function to generation the function body for a particular function
             -- and constructor
       where gen_render (conName, components) vars 
                 -- function name is based on constructor name  
               = let funcName = makeName $ unCapalize $ nameBase conName 
                 -- choose the correct builder function
                     headFunc = case vars of
                                     [] -> "func_out"
                                     otherwise -> "build" 
                      -- build 'funcName parm1 parm2 parm3 ...
                   in appsE $ (varE $ mkName headFunc):funcName:vars -- put it all together
             -- equivalent to 'funcStr where funcStr CONTAINS the name to be returned
             makeName funcStr = (appE (varE (mkName "mkName")) (litE $ StringL funcStr))
-}

--gen_iterable :: Name -> Name -> Name -> Name -> Q [Dec]
gen_iterable typA typB getter setter = 
  [d| instance Iterable $(typA) $(typB) where
        imapM   f a =
          do b' <- mapM f ( $(getter) a)
             return $ $(setter) a b'
        ifoldM  f e a = do r <- foldM f e ( $(getter) a)
                          return r
        ifoldl' f e a = foldl' f e ( $(getter) a)
        ifoldl  f e a = foldl  f e ( $(getter) a) 
        ifoldr  f e a = foldr  f e ( $(getter) a) |]

trans_iterable typA typB typC = 
  [d| instance Iterable $(typA) $(typC) where
        imapM  f a   = (imapM  :: (Monad m) => ( $(typB) -> m $(typB) ) -> $(typA)   -> m $(typA) ) (imapM f) a 
        imap   f a   = (imap   ::              ( $(typB) ->   $(typB) ) -> $(typA)   ->   $(typA) ) (imap  f) a 
        ifoldM f e a = (ifoldM :: (Monad m) => (c -> $(typB) -> m c) -> c -> $(typA)   -> m c       ) (ifoldM f) e a 
        ifold  f e a = (ifold  ::              (c -> $(typB) ->   c) -> c -> $(typA)   ->   c       ) (ifold f) e a
    |]

{-
 iget = undefined
 iset = undefined
    instance Iterable a b where
      imapM f a =
        do b' <- mapM f (iget a)
           return $ iset a b'
      ifoldM f e a = do r <- foldM f e ( iget a)
                        return r
      ifold  f e a = foldl f e ( iset a)
 -}

